1. When smoothing the CPU temperature, do you think you got a better result with LOESS or Kalman smoothing? What differences did you notice?

Both LOESS and Kalman smoothing provide noise reduction, but they behave differently. LOESS method uses one factor smooths the data based only on nearby points, resulting in a smooth curve that closely follows the local trends. Kalman smoothing use multiple variables (like CPU usage, system load, and fan RPM) and models the system's dynamics over time. In practice, LOESS may produce a smoother curve for temperature alone, while Kalman smoothing can better capture the underlying trend if the other variables are informative. 

2. In the CSV files, you might have also noticed other data about the observations: accelerometer (acceleration in x, y, z directions), gyroscope (rate of turning, pitch, roll, yaw). How could those have been used to make a better prediction about the “next” latitude and longitude?

Accelerometer and gyroscope data provide information about movement and orientation. By integrating acceleration, you can estimate changes in velocity and position, while gyroscope data helps track changes in direction. Including these as part of the state in a Kalman filter or similar model would allow the filter to predict the next latitude and longitude more accurately, especially during periods when GPS data is noisy or missing. 

3. [Optional] The transition matrix for the GPS Kalman filter had a sub-matrix that was [[5e-7, 34e-7], [-49e-7, 9e-7]] (which was found by regression to the true values). If you multiply that by 3e5, it looks a lot like a rotation matrix by 285°. The magnetic declination around Vancouver is about 15°. Explain that part of the transition matrix.

Multiplying the sub-matrix by 3e5 scales it to values similar to a rotation matrix, and the angle (285°) is related to the direction of movement or heading correction. The magnetic declination (15°) is the difference between magnetic north and true north. The transition matrix effectively rotates the velocity or movement vector to account for this difference, aligning the predicted path with true geographic directions rather than magnetic ones. This helps improve the accuracy of position predictions in regions with significant magnetic declination.

4. [Optional] In your calc_distance.py, temporarily set the transition_covariance values for the latitude and longitude to be very small (like 1/1000 of the corresponding observation_covariance values). This will give you a track in out.gpx that is basically "just the predictions, ignore the measurements". Have a look at the tracks on a viewer that includes a map (so you can see the track relative to roads/sidewalks). What can you infer about the predictions we're making?

When the transition_covariance for latitude and longitude is set very small, the filter relies almost entirely on its internal model and ignores the actual GPS measurements. As a result, the predicted track may drift away from the true path, especially if the model does not perfectly capture the real-world dynamics. This can lead to tracks that are smooth but do not follow roads or sidewalks accurately, highlighting the importance of balancing model predictions with real measurements.
